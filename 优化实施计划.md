# ä¼˜åŒ–å®æ–½è®¡åˆ’æ–‡æ¡£

## Beta ç³»æ•°è®¡ç®—ä¸ Winsorization å¼‚å¸¸å€¼å¤„ç†

---

## ğŸ“‹ æ–‡æ¡£ä¿¡æ¯

- **é¡¹ç›®åç§°**ï¼šç›¸å…³ç³»æ•°å¼‚å¸¸å‘Šè­¦ç³»ç»Ÿä¼˜åŒ–
- **ç‰ˆæœ¬**ï¼šv1.0
- **åˆ›å»ºæ—¥æœŸ**ï¼š2025-12-23
- **ç›®æ ‡æ–‡ä»¶**ï¼š`hyperliquid_analyzer.py`

---

## ä¸€ã€é¡¹ç›®æ¦‚è¿°

### 1.1 ä¼˜åŒ–ç›®æ ‡

æœ¬æ¬¡ä¼˜åŒ–æ—¨åœ¨å¢å¼º `hyperliquid_analyzer.py` çš„åˆ†æèƒ½åŠ›ï¼Œä¸»è¦åŒ…æ‹¬ï¼š

1. **æ·»åŠ  Beta ç³»æ•°è®¡ç®—**ï¼šè¡¡é‡å±±å¯¨å¸ç›¸å¯¹äº BTC çš„è·Ÿéšå¹…åº¦
2. **å®ç° Winsorization å¼‚å¸¸å€¼å¤„ç†**ï¼šæé«˜ç›¸å…³ç³»æ•°è®¡ç®—çš„ç¨³å¥æ€§

### 1.2 é¢„æœŸæ”¶ç›Š

- âœ… **æ›´å…¨é¢çš„åˆ†æ**ï¼šBeta ç³»æ•°è¡¥å……ç›¸å…³ç³»æ•°ï¼Œæä¾›è·Ÿéšå¹…åº¦ä¿¡æ¯
- âœ… **æ›´ç¨³å¥çš„ç»“æœ**ï¼šå¼‚å¸¸å€¼å¤„ç†å‡å°‘æç«¯å€¼å¯¹åˆ†æçš„å½±å“
- âœ… **æ›´å¥½çš„æ•°æ®è´¨é‡**ï¼šè¯†åˆ«å’Œå¤„ç†å¼‚å¸¸æ•°æ®ç‚¹

---

## äºŒã€æŠ€æœ¯èƒŒæ™¯

### 2.1 Beta ç³»æ•°

#### å®šä¹‰
Beta ç³»æ•°è¡¡é‡èµ„äº§ç›¸å¯¹äºåŸºå‡†ï¼ˆBTCï¼‰çš„ç³»ç»Ÿæ€§é£é™©æˆ–è·Ÿéšå¹…åº¦ã€‚

#### æ•°å­¦å…¬å¼

\[
\beta = \frac{\text{Cov}(R_{ALT}, R_{BTC})}{\text{Var}(R_{BTC})} = \frac{\sum_{i=1}^{n}(r_{ALT,i} - \bar{r}_{ALT})(r_{BTC,i} - \bar{r}_{BTC})}{\sum_{i=1}^{n}(r_{BTC,i} - \bar{r}_{BTC})^2}
\]

#### å«ä¹‰

- **Î² = 1.0**ï¼šALT ä¸ BTC åŒæ­¥æ³¢åŠ¨
- **Î² > 1.0**ï¼šALT æ³¢åŠ¨å¹…åº¦å¤§äº BTCï¼ˆæ›´æ•æ„Ÿï¼‰
- **Î² < 1.0**ï¼šALT æ³¢åŠ¨å¹…åº¦å°äº BTCï¼ˆæ›´ç¨³å®šï¼‰
- **Î² < 0**ï¼šALT ä¸ BTC åå‘æ³¢åŠ¨ï¼ˆç½•è§ï¼‰

### 2.2 Winsorization å¼‚å¸¸å€¼å¤„ç†

#### åŸç†
å°†æç«¯å€¼é™åˆ¶åœ¨æŒ‡å®šåˆ†ä½æ•°è¾¹ç•Œå†…ï¼Œè€Œä¸æ˜¯åˆ é™¤æ•°æ®ç‚¹ã€‚

#### æ–¹æ³•

- è®¡ç®—ä¸‹åˆ†ä½æ•°ï¼ˆå¦‚ 5%ï¼‰å’Œä¸Šåˆ†ä½æ•°ï¼ˆå¦‚ 95%ï¼‰
- å°†ä½äºä¸‹åˆ†ä½æ•°çš„å€¼æ›¿æ¢ä¸ºä¸‹åˆ†ä½æ•°
- å°†é«˜äºä¸Šåˆ†ä½æ•°çš„å€¼æ›¿æ¢ä¸ºä¸Šåˆ†ä½æ•°

#### ä¼˜åŠ¿

- âœ… ä¿ç•™æ‰€æœ‰æ•°æ®ç‚¹ï¼Œä¸å‡å°‘æ ·æœ¬é‡
- âœ… æœ‰æ•ˆå‡å°‘æç«¯å€¼çš„å½±å“
- âœ… åœ¨é‡‘èåˆ†æä¸­å¹¿æ³›åº”ç”¨

---

## ä¸‰ã€è¯¦ç»†å®æ–½è®¡åˆ’

### é˜¶æ®µ 1ï¼šæ·»åŠ é…ç½®å¸¸é‡

#### 3.1.1 ä¿®æ”¹ä½ç½®
`hyperliquid_analyzer.py` ç¬¬ 65-73 è¡Œï¼ˆç±»å¸¸é‡å®šä¹‰åŒºåŸŸï¼‰

#### 3.1.2 éœ€è¦æ·»åŠ çš„å¸¸é‡

```python
class DelayCorrelationAnalyzer:
    # ç°æœ‰å¸¸é‡
    MIN_POINTS_FOR_CORR_CALC = 10
    MIN_DATA_POINTS_FOR_ANALYSIS = 50
    
    # ========== æ–°å¢ï¼šå¼‚å¸¸å€¼å¤„ç†é…ç½® ==========
    # Winsorization åˆ†ä½æ•°é…ç½®
    WINSORIZE_LOWER_PERCENTILE = 5   # ä¸‹åˆ†ä½æ•°ï¼ˆ5%ï¼‰
    WINSORIZE_UPPER_PERCENTILE = 95  # ä¸Šåˆ†ä½æ•°ï¼ˆ95%ï¼‰
    # æ˜¯å¦å¯ç”¨å¼‚å¸¸å€¼å¤„ç†ï¼ˆå¯é…ç½®å¼€å…³ï¼‰
    ENABLE_OUTLIER_TREATMENT = True
    
    # ========== æ–°å¢ï¼šBeta ç³»æ•°é…ç½® ==========
    # æ˜¯å¦è®¡ç®— Beta ç³»æ•°ï¼ˆé»˜è®¤å¯ç”¨ï¼‰
    ENABLE_BETA_CALCULATION = True
    # Beta ç³»æ•°çš„æœ€å°æ•°æ®ç‚¹è¦æ±‚ï¼ˆä¸ç›¸å…³ç³»æ•°ç›¸åŒï¼‰
    MIN_POINTS_FOR_BETA_CALC = 10
```

#### 3.1.3 å®æ–½æ­¥éª¤

1. åœ¨ç±»å¸¸é‡åŒºåŸŸæ·»åŠ ä¸Šè¿°é…ç½®
2. æ·»åŠ æ³¨é‡Šè¯´æ˜æ¯ä¸ªå¸¸é‡çš„ç”¨é€”
3. ä¿æŒå‘åå…¼å®¹ï¼ˆé»˜è®¤å¯ç”¨æ–°åŠŸèƒ½ï¼‰

---

### é˜¶æ®µ 2ï¼šå®ç° Winsorization æ–¹æ³•

#### 3.2.1 æ–¹æ³•ç­¾å

```python
@staticmethod
def _winsorize_returns(returns, lower_p=None, upper_p=None, log_stats=False):
    """
    Winsorization å¼‚å¸¸å€¼å¤„ç†
    
    å°†æ”¶ç›Šç‡æ•°ç»„ä¸­çš„æç«¯å€¼é™åˆ¶åœ¨æŒ‡å®šåˆ†ä½æ•°èŒƒå›´å†…ï¼Œæé«˜ç»Ÿè®¡åˆ†æçš„ç¨³å¥æ€§ã€‚
    
    Args:
        returns: æ”¶ç›Šç‡æ•°ç»„ï¼ˆnumpy arrayï¼‰
        lower_p: ä¸‹åˆ†ä½æ•°ï¼ˆé»˜è®¤ä½¿ç”¨ç±»å¸¸é‡ WINSORIZE_LOWER_PERCENTILEï¼‰
        upper_p: ä¸Šåˆ†ä½æ•°ï¼ˆé»˜è®¤ä½¿ç”¨ç±»å¸¸é‡ WINSORIZE_UPPER_PERCENTILEï¼‰
        log_stats: æ˜¯å¦è®°å½•ç»Ÿè®¡ä¿¡æ¯åˆ°æ—¥å¿—ï¼ˆé»˜è®¤ Falseï¼‰
    
    Returns:
        å¤„ç†åçš„æ”¶ç›Šç‡æ•°ç»„ï¼ˆnumpy arrayï¼‰
    
    Note:
        - å¦‚æœæ•°æ®ç‚¹å°‘äº 20 ä¸ªï¼Œä¸è¿›è¡Œå¼‚å¸¸å€¼å¤„ç†ï¼ˆè¿”å›åŸæ•°ç»„ï¼‰
        - ä½¿ç”¨ np.clip è¿›è¡Œå¿«é€Ÿå¤„ç†
        - å¼‚å¸¸å€¼ä¼šè¢«é™åˆ¶åœ¨åˆ†ä½æ•°è¾¹ç•Œå†…ï¼Œè€Œä¸æ˜¯åˆ é™¤
    """
```

#### 3.2.2 å®ç°é€»è¾‘

```python
@staticmethod
def _winsorize_returns(returns, lower_p=None, upper_p=None, log_stats=False):
    # 1. å‚æ•°é»˜è®¤å€¼å¤„ç†
    if lower_p is None:
        lower_p = DelayCorrelationAnalyzer.WINSORIZE_LOWER_PERCENTILE
    if upper_p is None:
        upper_p = DelayCorrelationAnalyzer.WINSORIZE_UPPER_PERCENTILE
    
    # 2. æ•°æ®é‡æ£€æŸ¥ï¼šå¦‚æœæ•°æ®ç‚¹å¤ªå°‘ï¼Œä¸è¿›è¡Œå¼‚å¸¸å€¼å¤„ç†
    if len(returns) < 20:
        return returns
    
    # 3. è®¡ç®—åˆ†ä½æ•°è¾¹ç•Œ
    lower_bound = np.percentile(returns, lower_p)
    upper_bound = np.percentile(returns, upper_p)
    
    # 4. ç»Ÿè®¡å¼‚å¸¸å€¼æ•°é‡ï¼ˆç”¨äºæ—¥å¿—å’Œè°ƒè¯•ï¼‰
    n_lower_outliers = np.sum(returns < lower_bound)
    n_upper_outliers = np.sum(returns > upper_bound)
    total_outliers = n_lower_outliers + n_upper_outliers
    
    # 5. è®°å½•ç»Ÿè®¡ä¿¡æ¯ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if log_stats and total_outliers > 0:
        logger.debug(
            f"å¼‚å¸¸å€¼å¤„ç†ç»Ÿè®¡ | "
            f"ä¸‹ä¾§å¼‚å¸¸å€¼: {n_lower_outliers} | "
            f"ä¸Šä¾§å¼‚å¸¸å€¼: {n_upper_outliers} | "
            f"åˆ†ä½æ•°èŒƒå›´: [{lower_bound:.6f}, {upper_bound:.6f}] | "
            f"åŸå§‹æ•°æ®èŒƒå›´: [{np.min(returns):.6f}, {np.max(returns):.6f}]"
        )
    
    # 6. Winsorizationï¼šå°†æç«¯å€¼é™åˆ¶åœ¨åˆ†ä½æ•°èŒƒå›´å†…
    winsorized = np.clip(returns, lower_bound, upper_bound)
    
    return winsorized
```

#### 3.2.3 å®æ–½ä½ç½®
åœ¨ `find_optimal_delay` æ–¹æ³•ä¹‹å‰æ·»åŠ ï¼ˆçº¦ç¬¬ 219 è¡Œä¹‹å‰ï¼‰

---

### é˜¶æ®µ 3ï¼šå®ç° Beta ç³»æ•°è®¡ç®—æ–¹æ³•

#### 3.3.1 æ–¹æ³•ç­¾å

```python
@staticmethod
def _calculate_beta(btc_ret, alt_ret):
    """
    è®¡ç®— Beta ç³»æ•°
    
    è¡¡é‡å±±å¯¨å¸æ”¶ç›Šç‡ç›¸å¯¹äº BTC æ”¶ç›Šç‡çš„è·Ÿéšå¹…åº¦ã€‚
    
    Args:
        btc_ret: BTC æ”¶ç›Šç‡æ•°ç»„ï¼ˆnumpy arrayï¼‰
        alt_ret: å±±å¯¨å¸æ”¶ç›Šç‡æ•°ç»„ï¼ˆnumpy arrayï¼‰
    
    Returns:
        float: Beta ç³»æ•°å€¼
            - Beta > 1.0: ALT æ³¢åŠ¨å¹…åº¦å¤§äº BTC
            - Beta = 1.0: ALT ä¸ BTC åŒæ­¥æ³¢åŠ¨
            - Beta < 1.0: ALT æ³¢åŠ¨å¹…åº¦å°äº BTC
            - Beta < 0: ALT ä¸ BTC åå‘æ³¢åŠ¨ï¼ˆç½•è§ï¼‰
            - å¦‚æœæ•°æ®ä¸è¶³æˆ–è®¡ç®—å¤±è´¥ï¼Œè¿”å› np.nan
    
    Note:
        - Beta ç³»æ•°éœ€è¦è‡³å°‘ MIN_POINTS_FOR_BETA_CALC ä¸ªæ•°æ®ç‚¹
        - å¦‚æœ BTC æ”¶ç›Šç‡æ–¹å·®ä¸º 0ï¼Œè¿”å› np.nan
    """
```

#### 3.3.2 å®ç°é€»è¾‘

```python
@staticmethod
def _calculate_beta(btc_ret, alt_ret):
    # 1. æ•°æ®é•¿åº¦æ£€æŸ¥
    if len(btc_ret) != len(alt_ret):
        logger.warning(f"Beta è®¡ç®—å¤±è´¥ï¼šBTC å’Œ ALT æ•°æ®é•¿åº¦ä¸ä¸€è‡´ | "
                      f"BTC: {len(btc_ret)}, ALT: {len(alt_ret)}")
        return np.nan
    
    # 2. æœ€å°æ•°æ®ç‚¹æ£€æŸ¥
    if len(btc_ret) < DelayCorrelationAnalyzer.MIN_POINTS_FOR_BETA_CALC:
        return np.nan
    
    # 3. è®¡ç®—åæ–¹å·®å’Œæ–¹å·®
    try:
        # ä½¿ç”¨ numpy çš„ cov å‡½æ•°è®¡ç®—åæ–¹å·®çŸ©é˜µ
        # cov_matrix[0, 1] æ˜¯ BTC å’Œ ALT çš„åæ–¹å·®
        # cov_matrix[0, 0] æ˜¯ BTC çš„æ–¹å·®
        cov_matrix = np.cov(btc_ret, alt_ret)
        covariance = cov_matrix[0, 1]
        btc_variance = cov_matrix[0, 0]
        
        # 4. æ£€æŸ¥ BTC æ–¹å·®æ˜¯å¦ä¸º 0ï¼ˆé¿å…é™¤ä»¥ 0ï¼‰
        if btc_variance == 0 or np.isnan(btc_variance):
            logger.debug("Beta è®¡ç®—å¤±è´¥ï¼šBTC æ”¶ç›Šç‡æ–¹å·®ä¸º 0 æˆ– NaN")
            return np.nan
        
        # 5. è®¡ç®— Beta ç³»æ•°
        beta = covariance / btc_variance
        
        # 6. æ£€æŸ¥ç»“æœæœ‰æ•ˆæ€§
        if np.isnan(beta) or np.isinf(beta):
            logger.debug(f"Beta è®¡ç®—å¤±è´¥ï¼šç»“æœä¸º NaN æˆ– Inf | Beta: {beta}")
            return np.nan
        
        return beta
        
    except Exception as e:
        logger.warning(f"Beta è®¡ç®—å¼‚å¸¸ï¼š{type(e).__name__}: {str(e)}")
        return np.nan
```

#### 3.3.3 å®æ–½ä½ç½®
åœ¨ `_winsorize_returns` æ–¹æ³•ä¹‹åæ·»åŠ ï¼ˆçº¦ç¬¬ 219 è¡Œä¹‹å‰ï¼‰

---

### é˜¶æ®µ 4ï¼šå¢å¼º find_optimal_delay æ–¹æ³•

#### 3.4.1 æ–¹æ³•ç­¾åä¿®æ”¹

```python
@staticmethod
def find_optimal_delay(btc_ret, alt_ret, max_lag=3, enable_outlier_treatment=None, 
                       enable_beta_calc=None):
    """
    å¯»æ‰¾æœ€ä¼˜å»¶è¿Ÿ Ï„*ï¼ˆå¢å¼ºç‰ˆï¼šæ”¯æŒå¼‚å¸¸å€¼å¤„ç†å’Œ Beta ç³»æ•°è®¡ç®—ï¼‰
    
    é€šè¿‡è®¡ç®—ä¸åŒå»¶è¿Ÿä¸‹BTCå’Œå±±å¯¨å¸æ”¶ç›Šç‡çš„ç›¸å…³ç³»æ•°ï¼Œæ‰¾å‡ºä½¿ç›¸å…³ç³»æ•°æœ€å¤§çš„å»¶è¿Ÿå€¼ã€‚
    tau_star > 0 è¡¨ç¤ºå±±å¯¨å¸æ»åäºBTCï¼Œå­˜åœ¨æ—¶é—´å·®å¥—åˆ©æœºä¼šã€‚
    
    Args:
        btc_ret: BTCæ”¶ç›Šç‡æ•°ç»„
        alt_ret: å±±å¯¨å¸æ”¶ç›Šç‡æ•°ç»„
        max_lag: æœ€å¤§å»¶è¿Ÿå€¼ï¼ˆé»˜è®¤ 3ï¼Œæ ¹æ®å®é™…æ—¥å¿—æ•°æ®ä¼˜åŒ–ï¼‰
        enable_outlier_treatment: æ˜¯å¦å¯ç”¨å¼‚å¸¸å€¼å¤„ç†ï¼ˆNone æ—¶ä½¿ç”¨ç±»å¸¸é‡ï¼‰
        enable_beta_calc: æ˜¯å¦è®¡ç®— Beta ç³»æ•°ï¼ˆNone æ—¶ä½¿ç”¨ç±»å¸¸é‡ï¼‰
    
    Returns:
        tuple: (tau_star, corrs, max_related_matrix, beta)
            - tau_star: æœ€ä¼˜å»¶è¿Ÿå€¼
            - corrs: æ‰€æœ‰å»¶è¿Ÿå€¼å¯¹åº”çš„ç›¸å…³ç³»æ•°åˆ—è¡¨
            - max_related_matrix: æœ€å¤§ç›¸å…³ç³»æ•°
            - beta: Beta ç³»æ•°ï¼ˆå¦‚æœå¯ç”¨ï¼‰æˆ– None
    """
```

#### 3.4.2 å®ç°é€»è¾‘ä¿®æ”¹

```python
@staticmethod
def find_optimal_delay(btc_ret, alt_ret, max_lag=3, enable_outlier_treatment=None, 
                       enable_beta_calc=None):
    # ========== 1. å‚æ•°é»˜è®¤å€¼å¤„ç† ==========
    if enable_outlier_treatment is None:
        enable_outlier_treatment = DelayCorrelationAnalyzer.ENABLE_OUTLIER_TREATMENT
    if enable_beta_calc is None:
        enable_beta_calc = DelayCorrelationAnalyzer.ENABLE_BETA_CALCULATION
    
    # ========== 2. å¼‚å¸¸å€¼å¤„ç†ï¼ˆå¦‚æœå¯ç”¨ï¼‰==========
    if enable_outlier_treatment:
        btc_ret_processed = DelayCorrelationAnalyzer._winsorize_returns(
            btc_ret, log_stats=False
        )
        alt_ret_processed = DelayCorrelationAnalyzer._winsorize_returns(
            alt_ret, log_stats=False
        )
    else:
        btc_ret_processed = btc_ret
        alt_ret_processed = alt_ret
    
    # ========== 3. åŸæœ‰é€»è¾‘ï¼šè®¡ç®—ç›¸å…³ç³»æ•°å’Œæœ€ä¼˜å»¶è¿Ÿ ==========
    corrs = []
    lags = list(range(0, max_lag + 1))
    arr_len = len(btc_ret_processed)
    
    for lag in lags:
        # ... åŸæœ‰é€»è¾‘ä¿æŒä¸å˜ ...
        if lag > 0 and lag >= arr_len:
            corrs.append(np.nan)
            continue
        
        if lag > 0:
            x = btc_ret_processed[:-lag]
            y = alt_ret_processed[lag:]
        else:
            x = btc_ret_processed
            y = alt_ret_processed
        
        m = min(len(x), len(y))
        
        if m < DelayCorrelationAnalyzer.MIN_POINTS_FOR_CORR_CALC:
            corrs.append(np.nan)
            continue
        
        related_matrix = np.corrcoef(x[:m], y[:m])[0, 1]
        corrs.append(np.nan if np.isnan(related_matrix) else related_matrix)
    
    # æ‰¾å‡ºæœ€å¤§ç›¸å…³ç³»æ•°å¯¹åº”çš„å»¶è¿Ÿå€¼
    valid_corrs = np.array(corrs)
    valid_mask = ~np.isnan(valid_corrs)
    if valid_mask.any():
        valid_indices = np.where(valid_mask)[0]
        best_idx = valid_indices[np.argmax(valid_corrs[valid_mask])]
        tau_star = lags[best_idx]
        max_related_matrix = valid_corrs[best_idx]
    else:
        tau_star = 0
        max_related_matrix = np.nan
    
    # ========== 4. è®¡ç®— Beta ç³»æ•°ï¼ˆå¦‚æœå¯ç”¨ï¼‰==========
    beta = None
    if enable_beta_calc:
        # ä½¿ç”¨æœ€ä¼˜å»¶è¿Ÿå¯¹åº”çš„æ•°æ®è®¡ç®— Beta
        if tau_star > 0:
            btc_for_beta = btc_ret_processed[:-tau_star]
            alt_for_beta = alt_ret_processed[tau_star:]
        else:
            btc_for_beta = btc_ret_processed
            alt_for_beta = alt_ret_processed
        
        # ç¡®ä¿é•¿åº¦ä¸€è‡´
        m_beta = min(len(btc_for_beta), len(alt_for_beta))
        if m_beta >= DelayCorrelationAnalyzer.MIN_POINTS_FOR_BETA_CALC:
            beta = DelayCorrelationAnalyzer._calculate_beta(
                btc_for_beta[:m_beta], 
                alt_for_beta[:m_beta]
            )
    
    return tau_star, corrs, max_related_matrix, beta
```

#### 3.4.3 å‘åå…¼å®¹æ€§å¤„ç†

ä¸ºäº†ä¿æŒå‘åå…¼å®¹ï¼Œéœ€è¦å¤„ç†è°ƒç”¨æ–¹å¯èƒ½åªæ¥æ”¶ 3 ä¸ªè¿”å›å€¼çš„æƒ…å†µï¼š

```python
# åœ¨è°ƒç”¨ find_optimal_delay çš„åœ°æ–¹ï¼Œéœ€è¦æ›´æ–°è¿”å›å€¼æ¥æ”¶
# æ—§ä»£ç ï¼š
# tau_star, _, related_matrix = self.find_optimal_delay(...)

# æ–°ä»£ç ï¼š
# result = self.find_optimal_delay(...)
# if len(result) == 4:
#     tau_star, _, related_matrix, beta = result
# else:
#     tau_star, _, related_matrix = result
#     beta = None
```

---

### é˜¶æ®µ 5ï¼šæ›´æ–° _analyze_single_combination æ–¹æ³•

#### 3.5.1 ä¿®æ”¹ä½ç½®
`hyperliquid_analyzer.py` ç¬¬ 467-494 è¡Œ

#### 3.5.2 ä¿®æ”¹å†…å®¹

```python
def _analyze_single_combination(self, coin: str, timeframe: str, period: str) -> tuple | None:
    """
    åˆ†æå•ä¸ª timeframe/period ç»„åˆï¼ˆå¢å¼ºç‰ˆï¼šæ”¯æŒ Beta ç³»æ•°ï¼‰
    
    Returns:
        æˆåŠŸè¿”å› (correlation, timeframe, period, tau_star, beta)ï¼Œå¤±è´¥è¿”å› None
        æ³¨æ„ï¼šä¸ºäº†å‘åå…¼å®¹ï¼Œbeta å¯èƒ½ä¸º None
    """
    btc_df = self._get_btc_data(timeframe, period)
    if btc_df is None:
        return None
    
    alt_df = self._get_alt_data(coin, period, timeframe, coin)
    if alt_df is None:
        return None
    
    # å¯¹é½å’ŒéªŒè¯æ•°æ®
    aligned_data = self._align_and_validate_data(btc_df, alt_df, coin, timeframe, period)
    if aligned_data is None:
        return None
    btc_df_aligned, alt_df_aligned = aligned_data
    
    # è°ƒç”¨å¢å¼ºç‰ˆçš„ find_optimal_delay
    result = self.find_optimal_delay(
        btc_df_aligned['return'].values, 
        alt_df_aligned['return'].values
    )
    
    # å¤„ç†è¿”å›å€¼ï¼ˆæ”¯æŒæ–°æ—§ç‰ˆæœ¬ï¼‰
    if len(result) == 4:
        tau_star, _, related_matrix, beta = result
    else:
        # å‘åå…¼å®¹ï¼šå¦‚æœè¿”å› 3 ä¸ªå€¼ï¼Œbeta ä¸º None
        tau_star, _, related_matrix = result
        beta = None
    
    # å¢å¼ºæ—¥å¿—è¾“å‡º
    if beta is not None:
        logger.debug(
            f"åˆ†æç»“æœ | timeframe: {timeframe} | period: {period} | "
            f"tau_star: {tau_star} | ç›¸å…³ç³»æ•°: {related_matrix:.4f} | "
            f"Beta: {beta:.4f}"
        )
    else:
        logger.debug(
            f"åˆ†æç»“æœ | timeframe: {timeframe} | period: {period} | "
            f"tau_star: {tau_star} | ç›¸å…³ç³»æ•°: {related_matrix:.4f}"
        )
    
    return (related_matrix, timeframe, period, tau_star, beta)
```

---

### é˜¶æ®µ 6ï¼šæ›´æ–°ç»“æœå¤„ç†å’Œè¾“å‡º

#### 3.6.1 æ£€æŸ¥æ‰€æœ‰ä½¿ç”¨ `_analyze_single_combination` çš„åœ°æ–¹

éœ€è¦æ›´æ–°ä»¥ä¸‹æ–¹æ³•ï¼š
- `_detect_anomaly_pattern`ï¼šå¯èƒ½éœ€è¦è€ƒè™‘ Beta ç³»æ•°
- `_output_results`ï¼šè¾“å‡º Beta ç³»æ•°ä¿¡æ¯
- `one_coin_analysis`ï¼šå¤„ç†åŒ…å« Beta çš„ç»“æœ

#### 3.6.2 ä¿®æ”¹ _output_results æ–¹æ³•

```python
def _output_results(self, coin: str, results: list, diff_amount: float):
    """
    è¾“å‡ºåˆ†æç»“æœï¼ˆå¢å¼ºç‰ˆï¼šåŒ…å« Beta ç³»æ•°ï¼‰
    """
    # æ„å»ºç»“æœ DataFrame
    data_rows = []
    for result in results:
        # å¤„ç†æ–°æ—§æ ¼å¼
        if len(result) == 5:
            corr, tf, p, ts, beta = result
        else:
            corr, tf, p, ts = result
            beta = None
        
        row = {
            'æœ€å¤§ç›¸å…³ç³»æ•°': corr,
            'æ—¶é—´å‘¨æœŸ': tf,
            'æ•°æ®å‘¨æœŸ': p,
            'æœ€ä¼˜å»¶è¿Ÿ': ts
        }
        
        # æ·»åŠ  Beta ç³»æ•°åˆ—ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if beta is not None:
            row['Betaç³»æ•°'] = beta
        
        data_rows.append(row)
    
    df_results = pd.DataFrame(data_rows)
    
    # ... åç»­è¾“å‡ºé€»è¾‘ ...
```

---

## å››ã€æµ‹è¯•è®¡åˆ’

### 4.1 å•å…ƒæµ‹è¯•

#### æµ‹è¯• 1ï¼šWinsorization æ–¹æ³•
```python
def test_winsorize_returns():
    # æµ‹è¯•æ­£å¸¸æ•°æ®
    # æµ‹è¯•åŒ…å«å¼‚å¸¸å€¼çš„æ•°æ®
    # æµ‹è¯•æ•°æ®ç‚¹å°‘äº 20 çš„æƒ…å†µ
    # æµ‹è¯•è¾¹ç•Œæƒ…å†µï¼ˆæ‰€æœ‰å€¼ç›¸åŒï¼‰
    pass
```

#### æµ‹è¯• 2ï¼šBeta ç³»æ•°è®¡ç®—
```python
def test_calculate_beta():
    # æµ‹è¯•æ­£å¸¸æƒ…å†µï¼ˆBeta = 1.0ï¼‰
    # æµ‹è¯• Beta > 1.0 çš„æƒ…å†µ
    # æµ‹è¯• Beta < 1.0 çš„æƒ…å†µ
    # æµ‹è¯•æ•°æ®ä¸è¶³çš„æƒ…å†µ
    # æµ‹è¯• BTC æ–¹å·®ä¸º 0 çš„æƒ…å†µ
    pass
```

#### æµ‹è¯• 3ï¼šfind_optimal_delay å¢å¼ºç‰ˆ
```python
def test_find_optimal_delay_enhanced():
    # æµ‹è¯•å¯ç”¨å¼‚å¸¸å€¼å¤„ç†
    # æµ‹è¯•å¯ç”¨ Beta è®¡ç®—
    # æµ‹è¯•åŒæ—¶å¯ç”¨ä¸¤è€…
    # æµ‹è¯•å‘åå…¼å®¹æ€§
    pass
```

### 4.2 é›†æˆæµ‹è¯•

#### æµ‹è¯• 1ï¼šç«¯åˆ°ç«¯åˆ†ææµç¨‹
- ä½¿ç”¨çœŸå®æ•°æ®æµ‹è¯•å®Œæ•´åˆ†ææµç¨‹
- éªŒè¯å¼‚å¸¸å€¼å¤„ç†æ˜¯å¦æ­£å¸¸å·¥ä½œ
- éªŒè¯ Beta ç³»æ•°æ˜¯å¦æ­£ç¡®è®¡ç®—

#### æµ‹è¯• 2ï¼šæ€§èƒ½æµ‹è¯•
- å¯¹æ¯”ä¼˜åŒ–å‰åçš„è®¡ç®—æ—¶é—´
- éªŒè¯å¼‚å¸¸å€¼å¤„ç†ä¸ä¼šæ˜¾è‘—å½±å“æ€§èƒ½

### 4.3 å›å½’æµ‹è¯•

- ç¡®ä¿ç°æœ‰åŠŸèƒ½ä¸å—å½±å“
- éªŒè¯å‘åå…¼å®¹æ€§
- æ£€æŸ¥æ—¥å¿—è¾“å‡ºæ˜¯å¦æ­£ç¡®

---

## äº”ã€å®æ–½æ—¶é—´è¡¨

| é˜¶æ®µ | ä»»åŠ¡ | é¢„è®¡æ—¶é—´ | ä¼˜å…ˆçº§ |
|------|------|---------|--------|
| é˜¶æ®µ 1 | æ·»åŠ é…ç½®å¸¸é‡ | 0.5 å°æ—¶ | é«˜ |
| é˜¶æ®µ 2 | å®ç° Winsorization æ–¹æ³• | 1 å°æ—¶ | é«˜ |
| é˜¶æ®µ 3 | å®ç° Beta ç³»æ•°è®¡ç®— | 1 å°æ—¶ | é«˜ |
| é˜¶æ®µ 4 | å¢å¼º find_optimal_delay | 1.5 å°æ—¶ | é«˜ |
| é˜¶æ®µ 5 | æ›´æ–° _analyze_single_combination | 1 å°æ—¶ | é«˜ |
| é˜¶æ®µ 6 | æ›´æ–°ç»“æœå¤„ç†å’Œè¾“å‡º | 1 å°æ—¶ | ä¸­ |
| æµ‹è¯• | å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯• | 2 å°æ—¶ | é«˜ |
| æ–‡æ¡£ | æ›´æ–°ä»£ç æ³¨é‡Šå’Œæ–‡æ¡£ | 0.5 å°æ—¶ | ä¸­ |

**æ€»è®¡ï¼šçº¦ 8.5 å°æ—¶**

---

## å…­ã€é£é™©è¯„ä¼°ä¸åº”å¯¹

### 6.1 é£é™©è¯†åˆ«

| é£é™© | å½±å“ | æ¦‚ç‡ | åº”å¯¹æªæ–½ |
|------|------|------|---------|
| å‘åå…¼å®¹æ€§é—®é¢˜ | é«˜ | ä¸­ | ä½¿ç”¨æ¡ä»¶åˆ¤æ–­å¤„ç†æ–°æ—§è¿”å›å€¼æ ¼å¼ |
| æ€§èƒ½ä¸‹é™ | ä¸­ | ä½ | Winsorization è®¡ç®—é‡å°ï¼Œå½±å“å¯å¿½ç•¥ |
| Beta è®¡ç®—å¼‚å¸¸ | ä¸­ | ä½ | æ·»åŠ å¼‚å¸¸å¤„ç†å’Œæ—¥å¿—è®°å½• |
| å¼‚å¸¸å€¼å¤„ç†è¿‡åº¦ | ä¸­ | ä½ | ä½¿ç”¨å¯é…ç½®çš„åˆ†ä½æ•°é˜ˆå€¼ |

### 6.2 å›æ»šæ–¹æ¡ˆ

å¦‚æœå‡ºç°é—®é¢˜ï¼Œå¯ä»¥é€šè¿‡ä»¥ä¸‹æ–¹å¼å¿«é€Ÿå›æ»šï¼š

1. è®¾ç½® `ENABLE_OUTLIER_TREATMENT = False` ç¦ç”¨å¼‚å¸¸å€¼å¤„ç†
2. è®¾ç½® `ENABLE_BETA_CALCULATION = False` ç¦ç”¨ Beta è®¡ç®—
3. æ¢å¤ `find_optimal_delay` çš„åŸå§‹è¿”å›å€¼æ ¼å¼

---

## ä¸ƒã€éªŒæ”¶æ ‡å‡†

### 7.1 åŠŸèƒ½éªŒæ”¶

- [ ] Winsorization æ–¹æ³•æ­£ç¡®å®ç°ï¼Œèƒ½å¤„ç†å¼‚å¸¸å€¼
- [ ] Beta ç³»æ•°è®¡ç®—æ–¹æ³•æ­£ç¡®ï¼Œç»“æœåˆç†
- [ ] `find_optimal_delay` æ–¹æ³•å¢å¼ºååŠŸèƒ½æ­£å¸¸
- [ ] æ‰€æœ‰è°ƒç”¨ç‚¹å·²æ›´æ–°ï¼Œæ”¯æŒæ–°è¿”å›å€¼
- [ ] æ—¥å¿—è¾“å‡ºåŒ…å« Beta ç³»æ•°ä¿¡æ¯

### 7.2 è´¨é‡éªŒæ”¶

- [ ] ä»£ç é€šè¿‡å•å…ƒæµ‹è¯•
- [ ] ä»£ç é€šè¿‡é›†æˆæµ‹è¯•
- [ ] å‘åå…¼å®¹æ€§éªŒè¯é€šè¿‡
- [ ] æ€§èƒ½æ— æ˜æ˜¾ä¸‹é™
- [ ] ä»£ç æ³¨é‡Šå®Œæ•´

### 7.3 æ–‡æ¡£éªŒæ”¶

- [ ] ä»£ç æ³¨é‡Šå·²æ›´æ–°
- [ ] æ–¹æ³•æ–‡æ¡£å­—ç¬¦ä¸²å®Œæ•´
- [ ] é…ç½®å¸¸é‡æœ‰è¯´æ˜

---

## å…«ã€åç»­ä¼˜åŒ–å»ºè®®

### 8.1 çŸ­æœŸä¼˜åŒ–ï¼ˆ1-2 å‘¨å†…ï¼‰

1. æ·»åŠ  Beta ç³»æ•°çš„ç»Ÿè®¡æ˜¾è‘—æ€§æ£€éªŒ
2. åœ¨è¾“å‡ºç»“æœä¸­æ·»åŠ  Beta ç³»æ•°çš„å¯è§†åŒ–
3. ä¼˜åŒ–å¼‚å¸¸å€¼å¤„ç†çš„æ—¥å¿—è®°å½•

### 8.2 ä¸­æœŸä¼˜åŒ–ï¼ˆ1 ä¸ªæœˆå†…ï¼‰

1. æ”¯æŒè‡ªå®šä¹‰åˆ†ä½æ•°é˜ˆå€¼ï¼ˆé€šè¿‡é…ç½®æ–‡ä»¶ï¼‰
2. æ·»åŠ åˆ†æ–¹å‘ Beta ç³»æ•°ï¼ˆä¸Šæ¶¨/ä¸‹è·Œåˆ†åˆ«è®¡ç®—ï¼‰
3. æ·»åŠ  Beta ç³»æ•°çš„å†å²è¶‹åŠ¿åˆ†æ

### 8.3 é•¿æœŸä¼˜åŒ–ï¼ˆ3 ä¸ªæœˆå†…ï¼‰

1. è€ƒè™‘æ·»åŠ å…¶ä»–ç¨³å¥æ€§æŒ‡æ ‡ï¼ˆå¦‚ Spearman ç›¸å…³ç³»æ•°ï¼‰
2. å®ç°è‡ªé€‚åº”å¼‚å¸¸å€¼æ£€æµ‹ï¼ˆæ ¹æ®æ•°æ®ç‰¹å¾è°ƒæ•´é˜ˆå€¼ï¼‰
3. æ·»åŠ å¼‚å¸¸å€¼å¤„ç†çš„æ€§èƒ½ç›‘æ§

---

## ä¹ã€é™„å½•

### 9.1 ç›¸å…³å…¬å¼

#### Beta ç³»æ•°å…¬å¼

\[
\beta = \frac{\text{Cov}(R_{ALT}, R_{BTC})}{\text{Var}(R_{BTC})}
\]

#### Winsorization å…¬å¼

\[
x_i^{winsorized} = \begin{cases}
q_l & \text{if } x_i < q_l \\
x_i & \text{if } q_l \leq x_i \leq q_u \\
q_u & \text{if } x_i > q_u
\end{cases}
\]

### 9.2 å‚è€ƒèµ„æº

- NumPy æ–‡æ¡£ï¼š`np.cov`, `np.percentile`, `np.clip`
- é‡‘èæ—¶é—´åºåˆ—åˆ†æç›¸å…³æ–‡çŒ®
- å¼‚å¸¸å€¼å¤„ç†æœ€ä½³å®è·µ

---

## åã€æ–‡æ¡£ç‰ˆæœ¬å†å²

| ç‰ˆæœ¬ | æ—¥æœŸ | ä¿®æ”¹å†…å®¹ | ä½œè€… |
|------|------|---------|------|
| v1.0 | 2025-12-23 | åˆå§‹ç‰ˆæœ¬ | AI Assistant |

---

**æ–‡æ¡£ç»“æŸ**

---

> è¯¥è®¡åˆ’æ–‡æ¡£å¯ç›´æ¥ç”¨äºæŒ‡å¯¼å®æ–½ã€‚å»ºè®®æŒ‰é˜¶æ®µé€æ­¥å®æ–½ï¼Œå¹¶åœ¨æ¯ä¸ªé˜¶æ®µå®Œæˆåè¿›è¡Œæµ‹è¯•éªŒè¯ã€‚

